<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>哲学家吃饭问题</title>
    <link href="/2024/09/24/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/24/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h4><blockquote><p>在远古时代，一个富有的慈善家捐赠了一个学院来为5名知名的哲学家提供住处。每个哲学家都有一个房间来进行他专业的思考活动；这也有一个共用的餐厅，布置了一个圆桌，周围放着5把椅子，每一把都标出了坐在这的哲学家的名字。哲学家们按逆时针顺序围绕桌子做下。每个哲学家的左手边放着一个金叉子，而在桌子中间有一大碗意大利面，它会不时的被补充。哲学家期望用他大部分的时间思考；不过当他饿了的时候，他走向餐厅，坐在它自己的椅子上，拿起他左手边自己的叉子，然后把它插进意大利面。不过乱成一团的意大利面需要第二把叉子才能吃到嘴里。因此哲学家不得不拿起他右手边的叉子。当他吃完了他会放下两把叉子，从椅子上起来，并继续思考。当然，一把叉子一次同时只能被一名哲学家使用。如果其他哲学家需要它，他必须等待直到叉子再次可用。</p></blockquote><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><blockquote><p>建立哲学家数组，再建立每个哲学家左右两边叉子的编号。这样当这个哲学家吃饭的时候，就可以通过左右两边叉子的编号来判断是否可以吃饭。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::time;<br><span class="hljs-keyword">use</span> std::&#123;sync::Mutex, thread&#125;;<br><span class="hljs-keyword">use</span> std::sync::Arc;<br><br><br><span class="hljs-comment">// 哲学家对象</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Philosopher</span>&#123;<br>    name:<span class="hljs-type">String</span>, <span class="hljs-comment">// 名字</span><br>    left:<span class="hljs-type">usize</span>, <span class="hljs-comment">// 左边叉子的编号</span><br>    right:<span class="hljs-type">usize</span> <span class="hljs-comment">// 右边叉子的编号</span><br>&#125;<br><br><span class="hljs-comment">// 实现方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Philosopher</span> &#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name:&amp;<span class="hljs-type">str</span>,left:<span class="hljs-type">usize</span>,right:<span class="hljs-type">usize</span>)<span class="hljs-punctuation">-&gt;</span>Philosopher&#123;<br>        Philosopher&#123;<br>            name:name.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            left:left,<br>            right:right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 吃饭</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat</span>(&amp;<span class="hljs-keyword">self</span>,table:&amp;Table)&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_left</span> = table.forks[<span class="hljs-keyword">self</span>.left].<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_right</span> = table.forks[<span class="hljs-keyword">self</span>.right].<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is eating.&quot;</span>,<span class="hljs-keyword">self</span>.name);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(time::Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is done eating&quot;</span>,<span class="hljs-keyword">self</span>.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 桌子对象</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Table</span>&#123;<br>    forks:<span class="hljs-type">Vec</span>&lt;Mutex&lt;()&gt;&gt;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">table</span>=Arc::<span class="hljs-title function_ invoke__">new</span>(Table &#123;forks:<span class="hljs-built_in">vec!</span>[<br>        Mutex::<span class="hljs-title function_ invoke__">new</span>(()),<br>        Mutex::<span class="hljs-title function_ invoke__">new</span>(()),<br>        Mutex::<span class="hljs-title function_ invoke__">new</span>(()),<br>        Mutex::<span class="hljs-title function_ invoke__">new</span>(()),<br>        Mutex::<span class="hljs-title function_ invoke__">new</span>(()),<br>    ]&#125;);<br><br>    <span class="hljs-comment">// 哲学家们</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">philosophers</span>=<span class="hljs-built_in">vec!</span>[<br>        Philosopher::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;哲学家1&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<br>        Philosopher::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;哲学家2&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br>        Philosopher::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;哲学家3&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<br>        Philosopher::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;哲学家4&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),<br>        Philosopher::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;哲学家5&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>),<br>    ];<br><br>    <span class="hljs-comment">// 启动线程</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handles</span>:<span class="hljs-type">Vec</span>&lt;_&gt; =philosophers.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">map</span>(|p|&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">table</span>=table.<span class="hljs-title function_ invoke__">clone</span>();<br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> ||&#123;<br>            p.<span class="hljs-title function_ invoke__">eat</span>(&amp;table);<br>        &#125;)<br>    &#125;).<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">h</span> <span class="hljs-keyword">in</span> handles&#123;<br>        h.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h4><blockquote><p>虽然是一个非常简单的并发问题。但是通过这个问题，我了解到了Mutex的使用。同时使用rust的多线程，也让我更加熟悉了rust的语法。因为rust没有垃圾回收，所以很多对象的写法可能和c++不一样。通过哲学家吃饭问题，我们可以更好的熟悉rust的使用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2024/09/19/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2024/09/19/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h4><blockquote><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围  [−2^31^,2 <sup>31</sup> − 1 ] ，就返回 0。<br><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p></blockquote><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> ans &lt; math.MinInt32/<span class="hljs-number">10</span> || ans &gt; math.MaxInt32/<span class="hljs-number">10</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>digit := x % <span class="hljs-number">10</span><br>x /= <span class="hljs-number">10</span><br>ans = ans*<span class="hljs-number">10</span> + digit<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h4><p>&emsp;&emsp;通过代码分析，可以发现，该算法的时间复杂度为 O(log(x))，其中 x 是输入的整数。这是因为算法需要逐位处理输入整数的每一位数字，而输入整数的位数决定了算法的循环次数。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/19/hello-world/"/>
    <url>/2024/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p> Welcome to LaoTien’s Blog! This is my very first post.</p><p> 欢迎来到老铁的博客！这是我的第一篇博客。</p><p> I’m LaoTien, a student from China.</p><p> 我是老铁，一个来自中国的学生。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2024/09/13/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/09/13/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.</p><h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h4><ul><li>遍历链表，将链表中的值取出，组成一个整数，然后相加，最后将和转化为链表</li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-keyword">var</span> carry = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> current = &amp;ListNode&#123;&#125;<br><span class="hljs-keyword">var</span> result = current<br><span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>x = l1.Val<br>&#125;<br><span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>y = l2.Val<br>&#125;<br><br>sum := x + y + carry<br>carry = sum / <span class="hljs-number">10</span><br><br>current.Next = &amp;ListNode&#123;Val: sum % <span class="hljs-number">10</span>&#125;<br>current = current.Next<br><br><span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>l1 = l1.Next<br>&#125;<br><span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>l2 = l2.Next<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span> &#123;<br>current.Next = &amp;ListNode&#123;Val: carry&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result.Next<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4 复杂度分析"></a>4 复杂度分析</h4><ul><li>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</li><li>空间复杂度：O(max(m,n))，答案链表的长度最多为 max(m,n)+1。</li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>&emsp;这道题的难点在于如何将链表中的值转化为整数，然后相加，最后将和转化为链表。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2024/09/13/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/09/13/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h4><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><h4 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2 思路分析"></a>2 思路分析</h4><ul><li>滑动窗口</li></ul><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>target := <span class="hljs-string">&quot;&quot;</span><br>arr := strings.Split(s, <span class="hljs-string">&quot;&quot;</span>)<br>maxcout, count := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">if</span> target == <span class="hljs-string">&quot;&quot;</span> &#123;<br>target = arr[i]<br>count++<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> !strings.Contains(target, arr[i]) &#123;<br>target += arr[i]<br>count++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> count &gt; maxcout &#123;<br>maxcout = count<br>&#125;<br>target = target[strings.Index(target, arr[i])+<span class="hljs-number">1</span>:]<br>target = target + arr[i]<br>count = <span class="hljs-built_in">len</span>(target)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> count &gt; maxcout &#123;<br>maxcout = count<br>&#125;<br><span class="hljs-keyword">return</span> maxcout<br><br></code></pre></td></tr></table></figure><h4 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4 复杂度分析"></a>4 复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>&emsp; 滑动窗口的思路，通过两个指针，一个指向窗口的起始位置，一个指向窗口的结束位置，通过判断窗口内是否包含重复字符，来调整窗口的起始位置。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>椭圆曲线算法</title>
    <link href="/2024/08/12/ECDSA/"/>
    <url>/2024/08/12/ECDSA/</url>
    
    <content type="html"><![CDATA[<h2 id="ECDSA算法"><a href="#ECDSA算法" class="headerlink" title="ECDSA算法"></a>ECDSA算法</h2><p><img src="https://pic1.zhimg.com/v2-3a4252b86b3f16ec9eb38b2cc6e4e053_1440w.jpg?source=172ae18b" alt="椭圆曲线算法"></p><h3 id="一，什么是ECDSA算法"><a href="#一，什么是ECDSA算法" class="headerlink" title="一，什么是ECDSA算法"></a>一，什么是ECDSA算法</h3><blockquote><p>ECDSA全称：**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a>**  有兴趣的朋友可以去维基百科看看这个算法的算法原理。</p><p><strong>椭圆曲线数字签名算法</strong> 既然是签名算法，就不是用来加密的。也就是说数据是公开的，只是用来保护数据不被篡改。</p></blockquote><blockquote><p>签名本身将被分成两部分，称为<code>R</code>和<code>S</code>。为了验证签名的正确性，你只需要公钥（用私钥在曲线上面产生的点）并将公钥和签名的一部分<code>S</code>一起代入另外一个方程，如果这个签名是由私钥正确签名过的数字签名，那么它将给出签名的另外一部分<code>R</code>。简单来说，一个数字签名包含两个数字，<code>R</code>和<code>S</code>，然后你使用一个私钥来产生<code>R</code>和<code>S</code>，如果将公钥和<code>S</code>代入被选定的魔法数学方程给出<code>R</code>的话，这个签名就是有效的。仅仅知道公钥是无法知道私钥或者创建出数字签名。</p></blockquote><blockquote><p>通常<code>ECDSA</code>会总共使用160比特，它可以表示相当大的数，可以由49个数字在里面。</p></blockquote><h3 id="二，为什么要用签名算法"><a href="#二，为什么要用签名算法" class="headerlink" title="二，为什么要用签名算法"></a>二，为什么要用签名算法</h3><blockquote><p>大部分的时候我们都会拿AES算法来作比较。原因是AES是名副其实的加密算法。解密需要密钥。应用场景比如，用户的重要数据。密钥一般会存放于用户自己手里。但是密钥是这种算法的软肋。毕竟什么时候都需要用这个密钥才能解密。</p><p>对应AES破坏性的加密算法，ECDSA椭圆曲线签名算法，是在不破坏数据的前提下，对数据进行签名。而签名是用来验证数据是否被篡改过。</p></blockquote><h3 id="三，基础原理和算法"><a href="#三，基础原理和算法" class="headerlink" title="三，基础原理和算法"></a>三，基础原理和算法</h3><blockquote><p><strong>模运算</strong>：简单的说就是整数求余数。余数会在0~除数之间不断的变化。</p><p><strong>Hash</strong>: SHA1加密哈希，相对于模运算来说复杂的多的多，但是可以用模运算来解释。</p><p>由于SHA1产生Hash碰撞的可能性最低。所以如果想通过伪造数据来获取特定的hash是不可能的。</p></blockquote><h3 id="四，椭圆曲线密码学"><a href="#四，椭圆曲线密码学" class="headerlink" title="四，椭圆曲线密码学"></a>四，椭圆曲线密码学</h3><p><img src="https://www.zhihu.com/equation?tex=y%5E2+=+(x%5E3+a%5Ctimes+x+++b)+%5Cmod+p+%5C%5C"></p><blockquote><p>根据公式我们能够看到y的取值范围是  0到(p-1). </p></blockquote><ol><li>通过以下的两个方式，我们可以通过随机的数做系数进行多少次以下的推导。</li></ol><ul><li>椭圆曲线的点加法</li><li>椭圆曲线的点乘法</li></ul><ol start="2"><li>一个椭圆曲线乘法的特性是你有一个点<img src="https://www.zhihu.com/equation?tex=R=k%5Ctimes+P" alt="[公式]">，你知道<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">和 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]">，但是你无法据此求出<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">，因为这里并没有椭圆曲线减法或者椭圆曲线除法可用，你并不能通过<img src="https://www.zhihu.com/equation?tex=k=R/P" alt="[公式]">得到<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">。并且，因为你可以做成千上万次的加法，最终你只是知道在曲线上面结束的点，但是具体是如何到达这个点你也并不知道。你无法进行反向操作，得到与点<img src="https://www.zhihu.com/equation?tex=P" alt="[公式]">相乘以后给你点<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">的 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"></li></ol><blockquote><p>这种即便你知道原点和终点，但是无法知道被乘数是<code>ECDSA</code>算法背后安全性的所有基础，而这一原则也被称为**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Trapdoor_function">单向陷门函数</a>**。</p></blockquote><h3 id="五，椭圆曲线算法"><a href="#五，椭圆曲线算法" class="headerlink" title="五，椭圆曲线算法"></a>五，椭圆曲线算法</h3><blockquote><p>对于<code>ECDSA</code>算法，首先你需要知道你的曲线参数，一共有<img src="https://www.zhihu.com/equation?tex=a,b,p,N,G" alt="[公式]">，你已经了解<img src="https://www.zhihu.com/equation?tex=a" alt="[公式]">和 <img src="https://www.zhihu.com/equation?tex=b" alt="[公式]">是曲线方程的参数（<img src="https://www.zhihu.com/equation?tex=y%5E2=x%5E3+a+%5Ctimes+x+++b" alt="[公式]">）,<img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">是模运算的底，<img src="https://www.zhihu.com/equation?tex=N" alt="[公式]">是曲线上面点的个数，对于<code>ECDSA</code>，还需要一个参数<code>G</code>，它表示一个你所选中的一个参考的起始点。它可以是曲线上面的任意一点。</p><p>验证一个签名并不是只知道公钥就可以。首先还必须知道这个公钥是从什么曲线参数推导出来的。</p><p>总结一下：首先，你有一对密钥：公钥和私钥，私钥是一个随机数，也是160比特大小，公钥是将曲线上的点<img src="https://www.zhihu.com/equation?tex=G" alt="[公式]">与私钥相乘以后的曲线上的点。令<img src="https://www.zhihu.com/equation?tex=dA" alt="[公式]">表示私钥，一个随机数，<img src="https://www.zhihu.com/equation?tex=Qa" alt="[公式]">表示公钥，曲线上面的一个点，我们有<img src="https://www.zhihu.com/equation?tex=Qa+=+dA+%5Ctimes+G" alt="[公式]">，其中<img src="https://www.zhihu.com/equation?tex=G" alt="[公式]">是曲线上面的参考点。</p></blockquote><h3 id="六，总结"><a href="#六，总结" class="headerlink" title="六，总结"></a>六，总结</h3><blockquote><p>产生一个签名的两个方程，<img src="https://www.zhihu.com/equation?tex=R=k%5Ctimes+G" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=S=k%5E%7B-1%7D(z+dA%5Ctimes+R)+%5Cmod+p" alt="[公式]">，这些方程的强势在于实际上有一个方程里面有两个未知数（<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">和 <img src="https://www.zhihu.com/equation?tex=dA" alt="[公式]">)，因此你是无法确定其中的任意一个。</p><p>确保随机数<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">确实是随机产生的变得非常重要，并且没有人能够猜测、计算或者其它任何类型的攻击来得到随机数。</p><p><code>ECDSA</code>算法非常安全，不可能找到私钥。如果有办法很容易找到私钥，那么每台计算机、网站、系统的安全都可能受到危害，因为很多系统都依赖<code>ECDSA</code>来保证安全，而且不可能破解。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bufio</title>
    <link href="/2024/08/12/bufio/"/>
    <url>/2024/08/12/bufio/</url>
    
    <content type="html"><![CDATA[<h2 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>​流工具包，提供了读取器和写入器的对象创建和一些工具方法。</p><hr><p>一，包介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span><br><span class="hljs-comment">// object, creating another object (Reader or Writer) that also implements</span><br><span class="hljs-comment">// the interface but provides buffering and some help for textual I/O.</span><br><br>包bufio实现缓冲I/O。它包装一个io.Reader或io.Writer<br>实现了接口实现的对象<br>接口，但为文本I/O提供缓冲和一些工具<br><br>defaultBufSize=<span class="hljs-number">4096</span>  <span class="hljs-comment">//默认的bufsize</span><br><br></code></pre></td></tr></table></figure><p>二，Reader 结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Reader implements buffering for an io.Reader object.</span><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">struct</span> &#123;<br>buf          []<span class="hljs-type">byte</span><br>rd           io.Reader <span class="hljs-comment">// reader provided by the client</span><br>r, w         <span class="hljs-type">int</span>       <span class="hljs-comment">// buf read and write positions</span><br>err          <span class="hljs-type">error</span><br>lastByte     <span class="hljs-type">int</span> <span class="hljs-comment">// last byte read for UnreadByte; -1 means invalid</span><br>lastRuneSize <span class="hljs-type">int</span> <span class="hljs-comment">// size of last rune read for UnreadRune; -1 means invalid</span><br>&#125;<br>io.Reader 接口对象<br><span class="hljs-type">error</span> 接口对象，实现了Error() <span class="hljs-type">string</span> 的对象<br></code></pre></td></tr></table></figure><blockquote><p>用来存储读取内容的 buf  []byte 对象，io.Reader 读取器 ，读取位置和写入位置，错误信息对象。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span><br><span class="hljs-comment">// size. If the argument io.Reader is already a Reader with large enough</span><br><span class="hljs-comment">// size, it returns the underlying Reader.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReaderSize</span><span class="hljs-params">(rd io.Reader, size <span class="hljs-type">int</span>)</span></span> *Reader &#123;<br><span class="hljs-comment">// Is it already a Reader?</span><br>b, ok := rd.(*Reader)<br><span class="hljs-keyword">if</span> ok &amp;&amp; <span class="hljs-built_in">len</span>(b.buf) &gt;= size &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">if</span> size &lt; minReadBufferSize &#123; <span class="hljs-comment">//minReadBufferSize=16</span><br>size = minReadBufferSize<br>&#125;<br>r := <span class="hljs-built_in">new</span>(Reader)<br>r.reset(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size), rd)<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br><span class="hljs-comment">// NewReader returns a new Reader whose buffer has the default size.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(rd io.Reader)</span></span> *Reader &#123;<br><span class="hljs-keyword">return</span> NewReaderSize(rd, defaultBufSize)<br>&#125;<br><span class="hljs-comment">// Reset discards any buffered data, resets all state, and switches</span><br><span class="hljs-comment">// the buffered reader to read from r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> Reset(r io.Reader) &#123;<br>b.reset(b.buf, r)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> reset(buf []<span class="hljs-type">byte</span>, r io.Reader) &#123;<br>*b = Reader&#123;<br>buf:          buf,<br>rd:           r,<br>lastByte:     <span class="hljs-number">-1</span>,<br>lastRuneSize: <span class="hljs-number">-1</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果 rd已经是一个Reader 直接进行解包，如果size小于16更新为16，并生成Reader对象</p><p>Reset(r io.Reader)  重置一个io.Reader 对象的读取器buf []byte</p><p>NewReader 方法是一个接口，可以进行自定义读取。比如混淆。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReaderSimple</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>data := <span class="hljs-string">&quot;hello world&quot;</span><br>b := NewReader(strings.NewReader(data))<br><span class="hljs-keyword">if</span> s := readBytes(b); s != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;simple hello world test failed: got %q&quot;</span>, s)<br>&#125;<br><br>b = NewReader(newRot13Reader(strings.NewReader(data)))<br><span class="hljs-keyword">if</span> s := readBytes(b); s != <span class="hljs-string">&quot;uryyb jbeyq&quot;</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;rot13 hello world test failed: got %q&quot;</span>, s)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个测试读取器和一个自定义混淆读取器。下面我来看看它的实现吧。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Reads from a reader and rot13s the result.</span><br><span class="hljs-keyword">type</span> rot13Reader <span class="hljs-keyword">struct</span> &#123;<br>r io.Reader<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRot13Reader</span><span class="hljs-params">(r io.Reader)</span></span> *rot13Reader &#123;<br>r13 := <span class="hljs-built_in">new</span>(rot13Reader)<br>r13.r = r<br><span class="hljs-keyword">return</span> r13<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r13 *rot13Reader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>n, err := r13.r.Read(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>c := p[i] | <span class="hljs-number">0x20</span> <span class="hljs-comment">// lowercase byte</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;m&#x27;</span> &#123;<br>p[i] += <span class="hljs-number">13</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;n&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &#123;<br>p[i] -= <span class="hljs-number">13</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> n, err<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Read方法进行了混淆读取。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 源码分析-error</title>
    <link href="/2024/08/12/golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/08/12/golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Golang-源码分析-error"><a href="#Golang-源码分析-error" class="headerlink" title="Golang 源码分析-error"></a>Golang 源码分析-error</h3><hr><h3 id="Golang-源码分析"><a href="#Golang-源码分析" class="headerlink" title="Golang -源码分析"></a>Golang -源码分析</h3><p>error&#x2F;wrap.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Unwrap returns the result of calling the Unwrap method on err, if err&#x27;s</span><br><span class="hljs-comment">// type contains an Unwrap method returning error.</span><br><span class="hljs-comment">// Otherwise, Unwrap returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span>&#123;<br>u, ok := err.(<span class="hljs-keyword">interface</span> &#123;<br>Unwrap() <span class="hljs-type">error</span><br>&#125;)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> u.Unwrap()<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>处理接口对象是否满足某个接口的断言。感觉减少了错误的出现。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Is reports whether any error in err&#x27;s chain matches target.</span><br><span class="hljs-comment">// The chain consists of err itself followed by the sequence of errors obtained by</span><br><span class="hljs-comment">// repeatedly calling Unwrap.</span><br><span class="hljs-comment">// An error is considered to match a target if it is equal to that target or if</span><br><span class="hljs-comment">// it implements a method Is(error) bool such that Is(target) returns true.</span><br><span class="hljs-comment">// An error type might provide an Is method so it can be treated as equivalent</span><br><span class="hljs-comment">// to an existing error. For example, if MyError defines</span><br><span class="hljs-comment">//func (m MyError) Is(target error) bool &#123; return target == fs.ErrExist &#125;</span><br><span class="hljs-comment">// then Is(MyError&#123;&#125;, fs.ErrExist) returns true. See syscall.Errno.Is for</span><br><span class="hljs-comment">// an example in the standard library.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err == target<br>&#125;<br>isComparable := reflectlite.TypeOf(target).Comparable()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> isComparable &amp;&amp; err == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; Is(<span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> consider supporting target.Is(err). This would allow</span><br><span class="hljs-comment">// user-definable predicates, but also may allow for coping with sloppy</span><br><span class="hljs-comment">// APIs, thereby making it easier to get away with them.</span><br><span class="hljs-keyword">if</span> err = Unwrap(err); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Is reports whether any <span class="hljs-keyword">error</span> <span class="hljs-keyword">in</span> err&#x27;s chain matches target.<br>报告err链中是否有错误与目标匹配。<br>The chain consists <span class="hljs-keyword">of</span> err itself followed <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> sequence <span class="hljs-keyword">of</span> errors obtained <span class="hljs-keyword">by</span> repeatedly calling Unwrap.<br>该链由err本身和通过反复调用Unwrap获得的错误序列组成。<br>An <span class="hljs-keyword">error</span> <span class="hljs-keyword">is</span> considered <span class="hljs-keyword">to</span> match a target <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">equal</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">that</span> target <span class="hljs-keyword">or</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> implements a method Is(<span class="hljs-keyword">error</span>) bool such <span class="hljs-keyword">that</span> Is(target) returns <span class="hljs-literal">true</span>.<br>如果一个错误等于该目标，或者它实现了一个方法（错误）bool，那么（target）返回<span class="hljs-literal">true</span>，则认为该错误与目标匹配。<br>An <span class="hljs-keyword">error</span> type might provide an Is method so <span class="hljs-keyword">it</span> can be treated <span class="hljs-keyword">as</span> equivalent <span class="hljs-keyword">to</span> an existing <span class="hljs-keyword">error</span>. For example, <span class="hljs-keyword">if</span> MyError defines<br>错误类型可能提供Is方法，以便将其视为等效于现有错误。例如，如果MyError定义<br>func (m MyError) Is(target <span class="hljs-keyword">error</span>) bool &#123; <span class="hljs-literal">return</span> target == fs.ErrExist &#125;<br><span class="hljs-keyword">then</span> Is(MyError&#123;&#125;, fs.ErrExist) returns <span class="hljs-literal">true</span>. See syscall.Errno.Is <span class="hljs-keyword">for</span> an example <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> standard library.<br>然后 Is（MyError&#123;&#125;，fs.ErrExist）返回<span class="hljs-literal">true</span>。有关标准库中的示例，请参见syscall.Errno.Is。<br></code></pre></td></tr></table></figure><blockquote><p>判断发生的错误的类型，返回boolean。主要是实现过程，</p><ul><li>目标错误不能是nil</li><li>反射获取目标错误的可比较状态</li><li>错误依次拆箱，直到找到符合的目标错误。</li></ul><p>以后再高层的业务逻辑判断错误的时候，会考虑使用此方法来确定业务的具体错误进行有针对的返回错误。</p></blockquote><p>除了Is方法外还有一个As方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// As finds the first error in err&#x27;s chain that matches target, and if so, sets</span><br><span class="hljs-comment">// target to that error value and returns true. Otherwise, it returns false.</span><br><span class="hljs-comment">// The chain consists of err itself followed by the sequence of errors obtained by</span><br><span class="hljs-comment">// repeatedly calling Unwrap.</span><br><span class="hljs-comment">// An error matches target if the error&#x27;s concrete value is assignable to the value</span><br><span class="hljs-comment">// pointed to by target, or if the error has a method As(interface&#123;&#125;) bool such that</span><br><span class="hljs-comment">// As(target) returns true. In the latter case, the As method is responsible for</span><br><span class="hljs-comment">// setting target.</span><br><span class="hljs-comment">// An error type might provide an As method so it can be treated as if it were a</span><br><span class="hljs-comment">// different error type.</span><br><span class="hljs-comment">// As panics if target is not a non-nil pointer to either a type that implements</span><br><span class="hljs-comment">// error, or to any interface type.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err <span class="hljs-type">error</span>, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: target cannot be nil&quot;</span>)<br>&#125;<br>val := reflectlite.ValueOf(target)<br>typ := val.Type()<br><span class="hljs-keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: target must be a non-nil pointer&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;errors: *target must be interface or implement error&quot;</span>)<br>&#125;<br>targetType := typ.Elem()<br><span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;<br>val.Elem().Set(reflectlite.ValueOf(err))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; As(<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>err = Unwrap(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">As在err的链中查找与<span class="hljs-keyword">target</span>匹配的第一个错误，如果是，则将<span class="hljs-keyword">target</span>设置为该错误值并返回<span class="hljs-keyword">true</span>。否则，返回<span class="hljs-keyword">false</span>。<br>该链由err本身和通过反复调用Unwrap获得的错误序列组成。<br>如果错误的具体值可赋值给<span class="hljs-keyword">target</span>所指向的值，或者错误的方法为（<span class="hljs-class"><span class="hljs-keyword">interface</span></span>&#123;&#125;）bool，例如As（<span class="hljs-keyword">target</span>）返回<span class="hljs-keyword">true</span>，则错误与<span class="hljs-keyword">target</span>匹配。在后一种情况下，As方法负责设置目标。<br>错误类型可能提供As方法，因此可以将其视为不同的错误类型。<br>如果<span class="hljs-keyword">target</span>不是指向实现<span class="hljs-keyword">error</span>的类型或任何接口类型的非nil指针，则As panics。<br></code></pre></td></tr></table></figure><blockquote><p>其实只从代码的实现来看，我觉得这个方法就没有多少实用性，主要是动不动就panic 。毕竟我在处理错误现场呢，就是为了更加准确的判断是哪里出了错误，没必要再崩溃一次吧。。。</p></blockquote><p>至此，errors&#x2F;wrap.go就介绍完毕了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​一直以来，我都有反射会大大降低代码的运行效率，但是今天看源码发现，也没有大大降低，这就看情况有没有必要了。如果我们在收拾残局，做程序的善后处理，你还关注效率吗？肯定不是，而是到底问题出在那里了。对不对？</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两阶段提交(2PC)</title>
    <link href="/2024/08/12/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <url>/2024/08/12/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="两阶段提交-2PC"><a href="#两阶段提交-2PC" class="headerlink" title="两阶段提交(2PC)"></a>两阶段提交(2PC)</h2><hr><blockquote><p>分布式事务的基本理论：基本遵循CPA理论，采用柔性事务特征，软状态或者最终一致性特点来保证最终一致性问题。</p></blockquote><h3 id="一，两阶段提交-2PC"><a href="#一，两阶段提交-2PC" class="headerlink" title="一，两阶段提交(2PC)"></a>一，两阶段提交(2PC)</h3><blockquote><p>是一个非常经典的 <strong>强一致性，中心化的原子提交协议</strong></p></blockquote><blockquote><p>一个中心化的协调者节点，N个参与者节点组成。</p></blockquote><blockquote><p>两个阶段：一个是投票阶段，提交&#x2F;执行阶段。</p></blockquote><h4 id="第一个阶段分为三步："><a href="#第一个阶段分为三步：" class="headerlink" title="第一个阶段分为三步："></a>第一个阶段分为三步：</h4><p>第一步，<strong>协调者</strong>向所有的<strong>参与者</strong>发送事务预处理请求，并开始等待<strong>参与者</strong>的响应。</p><p>第二步，各个<strong>参与者</strong>执行本地事务操作，执行完成之后并不会提交本地的数据库事务。先向<strong>协调者</strong>报告是否可以执行本次的事务。</p><p>第三步，<strong>协调者</strong>收到各个<strong>参与者</strong>的本地执行事务的状态，一般也就两类情况，1，全部yes。2，部分或是全部no。</p><p><img src="https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222443794-591603727.jpg"></p><h4 id="第二阶段（正常情况"><a href="#第二阶段（正常情况" class="headerlink" title="第二阶段（正常情况)"></a>第二阶段（正常情况)</h4><p>第一步， <strong>协调者</strong> 向 <strong>所有参与者</strong> 节点发出Commit请求。</p><p>第二步，<strong>参与者</strong> 收到Commit请求之后,就会正式执行本地事务Commit操作,并在完成提交之后释放整个事务执行期间占用的事务资源</p><h4 id="第二阶段（异常情况）"><a href="#第二阶段（异常情况）" class="headerlink" title="第二阶段（异常情况）"></a>第二阶段（异常情况）</h4><p>第一步，<strong>协调者</strong> 向所有参与者节点发出 <strong>RoollBack</strong> 请求。</p><p>第二步，<strong>参与者</strong> 接收到RoollBack请求后,会回滚本地事务。</p><h3 id="二，2PC的缺点"><a href="#二，2PC的缺点" class="headerlink" title="二，2PC的缺点"></a>二，2PC的缺点</h3><p>缺陷：</p><ul><li>性能问题，无论第一阶段的过程中还是第二阶段过程中所有参与者资源都是被锁住的。只有所有的节点都准备完毕，事务协调者才发起全局提交。过程比较长，对性能影响比较大。</li><li>单节点故障，由于协调者非常重要，一旦协调者发生故障。参会者会一直阻塞下去。尤其是在第二阶段。虽然协调者挂掉可以重新选择一个，但是无法解决协调者宕机导致的参与者处于阻塞状态的问题。</li></ul><h3 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h3><blockquote><p>重点是第二阶段，虽然只有两步，但是发生问题之后，不太好解决，因为参与者状态容易不一致。单点故障发生的概率还是比较常见的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三阶段提交（3PC）</title>
    <link href="/2024/08/12/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <url>/2024/08/12/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a>三阶段提交（3PC）</h2><hr><h3 id="一，前言"><a href="#一，前言" class="headerlink" title="一，前言"></a>一，前言</h3><blockquote><p>三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞。三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。</p></blockquote><h3 id="二，改动点"><a href="#二，改动点" class="headerlink" title="二，改动点"></a>二，改动点</h3><blockquote><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的</li></ul></blockquote><h3 id="三，第一阶段-CanCommit"><a href="#三，第一阶段-CanCommit" class="headerlink" title="三，第一阶段   CanCommit"></a>三，第一阶段   CanCommit</h3><blockquote><p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p></blockquote><h3 id="四，第二阶段-PreCommit"><a href="#四，第二阶段-PreCommit" class="headerlink" title="四，第二阶段  PreCommit"></a>四，第二阶段  PreCommit</h3><blockquote><p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p></blockquote><h3 id="五，第三阶段-doCommit"><a href="#五，第三阶段-doCommit" class="headerlink" title="五，第三阶段 doCommit"></a>五，第三阶段 doCommit</h3><h4 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交:"></a><strong>执行提交</strong>:</h4><blockquote><p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p><p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p></blockquote><h4 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a><strong>中断事务</strong></h4><blockquote><p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p><p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p><p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p><p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></blockquote><h3 id="六，总结"><a href="#六，总结" class="headerlink" title="六，总结"></a>六，总结</h3><blockquote><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</p><p><strong>世上只有一种一致性算法，那就是Paxos</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串--字符串</title>
    <link href="/2024/08/12/%E4%B8%B2/"/>
    <url>/2024/08/12/%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="串–字符串"><a href="#串–字符串" class="headerlink" title="串–字符串"></a>串–字符串</h2><h3 id="一，前言"><a href="#一，前言" class="headerlink" title="一，前言"></a>一，前言</h3><ul><li>串的定义</li></ul><blockquote><p>串是由零个或多个字符组成的有限序列，又名字符串。</p></blockquote><ul><li><p>空字符串</p><blockquote><p>零个字符的串就是空串。也就是常说的  “”</p></blockquote></li></ul><h3 id="二，串的比较"><a href="#二，串的比较" class="headerlink" title="二，串的比较"></a>二，串的比较</h3><ul><li>字符串的比较实际是比较字符的值，根据不同的编码进行存储，最初的ASCII 到 Unicode。从最初的128个字符，到65w多。</li><li>字符串的长度一样，每一个相对位置的字符值都一样，就可以说这两个字符串是相等的。</li></ul><h3 id="三，串的顺序存储结构"><a href="#三，串的顺序存储结构" class="headerlink" title="三，串的顺序存储结构"></a>三，串的顺序存储结构</h3><blockquote><p>就是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的串的大小为串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p></blockquote><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>两个串进行拼接，新串的插入，以及字符串的替换操作都有可能使得串的长度超过数组的长度。</li><li>如果溢出就会出现字符串被截断的问题。</li></ul><h3 id="四，串的链式存储结构"><a href="#四，串的链式存储结构" class="headerlink" title="四，串的链式存储结构"></a>四，串的链式存储结构</h3><blockquote><p>就是用链表来存储串的内容。</p></blockquote><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>虽然解决了顺序存储的空间问题，但是每个node存储字符多少合适不好考量，因为会直接影响处理效率。</li><li>总的来说灵活性没有顺序结构，性能也不如顺序结构。</li></ul><h3 id="五，字符串匹配"><a href="#五，字符串匹配" class="headerlink" title="五，字符串匹配"></a>五，字符串匹配</h3><h4 id="1，朴素的字符串匹配"><a href="#1，朴素的字符串匹配" class="headerlink" title="1，朴素的字符串匹配"></a>1，朴素的字符串匹配</h4><p>字符串 S  匹配串 T</p><blockquote><p>简单总结就是S做大循环，每个字符进行T的小循环。</p></blockquote><p>举一个极端的例子。S&#x3D;”00000000000000000000000000000000000000001”  T&#x3D;”0000001”。</p><p>T 的0越多，循环次数越多。</p><h4 id="2，KMP匹配算法"><a href="#2，KMP匹配算法" class="headerlink" title="2，KMP匹配算法"></a>2，KMP匹配算法</h4><blockquote><p>KMP算法，是三个人参与的算法，我们称之为 克努特-莫里斯-普拉特算法</p></blockquote><p>算法的关键在于，分析匹配串的每个字符串的位置和匹配初始位置。</p><p>golang实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// KMP 匹配算法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KMP</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>, pos <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i := pos<br>    j := <span class="hljs-number">1</span><br>    next := getNextval(t)<br>    slen := <span class="hljs-built_in">len</span>(s)<br>    tmplen := <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">for</span> i &lt; slen &amp;&amp; j &lt; tmplen &#123;<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> || s[i] == t[j] &#123;<br>            i++<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> j == tmplen &#123;<br>        <span class="hljs-keyword">return</span> i - tmplen<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据匹配串得出匹配开始位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> i, j <span class="hljs-type">int</span><br>    i = <span class="hljs-number">1</span><br>    j = <span class="hljs-number">0</span><br>    next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(t)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(t) &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(t) &#123;<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> || t[i] == t[j] &#123;<br>            i++<br>            j++<br>            next[i] = j<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next<br>&#125;<br><br><span class="hljs-comment">// 根据匹配串得出匹配开始位置 优化版</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNextval</span><span class="hljs-params">(t <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> i, j <span class="hljs-type">int</span><br>    i = <span class="hljs-number">1</span><br>    j = <span class="hljs-number">0</span><br>    next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(t)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(t) &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(t) &#123;<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> || t[i] == t[j] &#123;<br>            <span class="hljs-comment">// next[i] = j</span><br>            <span class="hljs-keyword">if</span> t[i] != t[j] &#123;<br>                next[i] = j<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next[i] = next[j]<br>            &#125;<br>            i++<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang">tem: ABACAABAC<br>getNext(t): [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>PASS<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">s: afeincseifnsliwneit<br>tmp: fnsliwn<br>KMP(s, t, <span class="hljs-number">0</span>): <span class="hljs-number">9</span><br>PASS<br></code></pre></td></tr></table></figure><h3 id="六，总结"><a href="#六，总结" class="headerlink" title="六，总结"></a>六，总结</h3><blockquote><p>字符串的循环累加，会消耗大量的空间，一般语言会实现字符串的累加优化。下期针对字符串的累加优化进行golang的学习。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2024/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><hr><ul><li>单例模式介绍</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">保证一个类仅有一个实例，并提供一个访问它的全局访问点<br></code></pre></td></tr></table></figure><ul><li>懒汉单例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>懒汉式，线程不安全，也就是单线程内是单例的，多线程就不一定了</p><ul><li>懒汉线程安全的单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>饿汉式单例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双检查线程锁单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;  <br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>        &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> singleton;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态内部类单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>枚举单例模式(JDK1.5起)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    INSTANCE;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whateverMethod</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法  上篇</title>
    <link href="/2024/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8A/"/>
    <url>/2024/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法-上篇"><a href="#经典排序算法-上篇" class="headerlink" title="经典排序算法  上篇"></a>经典排序算法  上篇</h2><hr><h3 id="一，准备工作"><a href="#一，准备工作" class="headerlink" title="一，准备工作"></a>一，准备工作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//获取随机的数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArry</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, count)<br>rand.Seed(time.Now().UnixNano())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>arr[i] = rand.Intn(<span class="hljs-number">100</span>)<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;打印:&quot;</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Println(k)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二，冒泡排序"><a href="#二，冒泡排序" class="headerlink" title="二，冒泡排序"></a>二，冒泡排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>l := <span class="hljs-built_in">len</span>(arr)<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; l<span class="hljs-number">-1</span>-i; j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>tmp := arr[j+<span class="hljs-number">1</span>]<br>arr[j+<span class="hljs-number">1</span>] = arr[j]<br>arr[j] = tmp<br>&#125;<br>count++<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;冒泡排序次数：&quot;</span>, count)<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>冒泡排序是一种简单的排序算法。它重复的遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把他们交换过来。冒泡就是把越小的元素经由交换慢慢显现出来。</p></blockquote><h3 id="三，选择排序"><a href="#三，选择排序" class="headerlink" title="三，选择排序"></a>三，选择排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//选择排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>l := <span class="hljs-built_in">len</span>(arr)<br><span class="hljs-keyword">var</span> minindex, tmp, count <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br>minindex = i<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; l; j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; arr[minindex] &#123;<br>minindex = j<br>&#125;<br>count++<br>&#125;<br>tmp = arr[i]<br>arr[i] = arr[minindex]<br>arr[minindex] = tmp<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;选择排序次数：&quot;</span>, count)<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>选择排序是一种比较直观的排序算法。首先在未排序列中找到最小(大)的元素，放到起始位置，然后，再从剩余的未排序的元素中继续寻找最小(大)元素，然后放到排序序列的末尾。以此类推，直到排序完成。</p></blockquote><h3 id="四，插入排序"><a href="#四，插入排序" class="headerlink" title="四，插入排序"></a>四，插入排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//插入排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>l := <span class="hljs-built_in">len</span>(arr)<br><span class="hljs-keyword">var</span> preindex, curr <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; l; i++ &#123;<br>preindex = i - <span class="hljs-number">1</span><br>curr = arr[i]<br><span class="hljs-keyword">for</span> preindex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preindex] &gt; curr &#123;<br>arr[preindex+<span class="hljs-number">1</span>] = arr[preindex]<br>preindex--<br>&#125;<br>arr[preindex+<span class="hljs-number">1</span>] = curr<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>插入排序算法描述的是一种简单直观的构建有序序列的排序算法。工作原理是 对于未排序的数据，在已排序的数据从后向前进行扫描，找到相应的位置并插入。</p></blockquote><h3 id="五，希尔排序"><a href="#五，希尔排序" class="headerlink" title="五，希尔排序"></a>五，希尔排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^1.3^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>l := <span class="hljs-built_in">len</span>(arr)<br>middle := math.Floor(<span class="hljs-type">float64</span>(l / <span class="hljs-number">2</span>))<br><span class="hljs-keyword">for</span> gap := <span class="hljs-type">int</span>(middle); gap &gt; <span class="hljs-number">0</span>; gap = <span class="hljs-type">int</span>(math.Floor(<span class="hljs-type">float64</span>(gap / <span class="hljs-number">2</span>))) &#123;<br><span class="hljs-keyword">for</span> i := gap; i &lt; l; i++ &#123;<br>j := i<br>curr := arr[i]<br><span class="hljs-keyword">for</span> j-gap &gt;= <span class="hljs-number">0</span> &amp;&amp; curr &lt; arr[j-gap] &#123;<br>arr[j] = arr[j-gap]<br>j = j - gap<br>&#125;<br>arr[j] = curr<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>1959年Shell发明，第一个突破O(n^2^)的排序算法，是简单插入排序的改进版。与插入排序不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p></blockquote><h3 id="六，归并排序"><a href="#六，归并排序" class="headerlink" title="六，归并排序"></a>六，归并排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(nlog<del>2</del>n)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> start &gt;= end &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (start + end) / <span class="hljs-number">2</span><br>mergeSort(arr, start, mid)<br>mergeSort(arr, mid+<span class="hljs-number">1</span>, end)<br>merge(arr, start, mid, end)<br>&#125;<br><span class="hljs-comment">//划分不同的分区</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, mid, end <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> tmparr = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">var</span> s1, s2 = start, mid + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> s1 &lt;= mid &amp;&amp; s2 &lt;= end &#123;<br><span class="hljs-keyword">if</span> arr[s1] &gt; arr[s2] &#123;<br>tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s2])<br>s2++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s1])<br>s1++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s1 &lt;= mid &#123;<br>tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s1:mid+<span class="hljs-number">1</span>]...)<br>&#125;<br><span class="hljs-keyword">if</span> s2 &lt;= end &#123;<br>tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s2:end+<span class="hljs-number">1</span>]...)<br>&#125;<br><span class="hljs-keyword">for</span> pos, item := <span class="hljs-keyword">range</span> tmparr &#123;<br>arr[start+pos] = item<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法采用的是分治法的一个非常经典的应用。将已有序的子序列进行合并得到完全有序的序列。</p></blockquote><h3 id="七，总结"><a href="#七，总结" class="headerlink" title="七，总结"></a>七，总结</h3><blockquote><p>排序算法，排序对于查询来说有着非凡的意义。如果想要快速的查询数据，排序是避不开的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法  下篇</title>
    <link href="/2024/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8B/"/>
    <url>/2024/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法-下篇"><a href="#经典排序算法-下篇" class="headerlink" title="经典排序算法  下篇"></a>经典排序算法  下篇</h2><hr><h3 id="一，准备工作"><a href="#一，准备工作" class="headerlink" title="一，准备工作"></a>一，准备工作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//获取随机的数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArry</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, count)<br>rand.Seed(time.Now().UnixNano())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>arr[i] = rand.Intn(<span class="hljs-number">100</span>)<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;打印:&quot;</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Println(k)<br>&#125;<br>&#125;<br><span class="hljs-comment">//交换位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><span class="hljs-comment">//获取最大的元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArryMax</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>biger := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br><span class="hljs-keyword">if</span> v &gt; biger &#123;<br>biger = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> biger<br>&#125;<br><span class="hljs-comment">//获取数字位的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digit</span><span class="hljs-params">(num <span class="hljs-type">int</span>, loc <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num % <span class="hljs-type">int</span>(math.Pow10(loc)) / <span class="hljs-type">int</span>(math.Pow10(loc<span class="hljs-number">-1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二，快速排序"><a href="#二，快速排序" class="headerlink" title="二，快速排序"></a>二，快速排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(n^2^)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> start &lt; end &#123;<br>i, j := start, end<br>key := arr[(start+end)/<span class="hljs-number">2</span>]<br><span class="hljs-keyword">for</span> i &lt;= j &#123;<br><span class="hljs-keyword">for</span> arr[i] &lt; key &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> arr[j] &gt; key &#123;<br>j--<br>&#125;<br><span class="hljs-keyword">if</span> i &lt;= j &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>i++<br>j--<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> start &lt; j &#123;<br>quickSort(arr, start, j)<br>&#125;<br><span class="hljs-keyword">if</span> end &gt; i &#123;<br>quickSort(arr, i, end)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_FastSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>arr := GetArry(<span class="hljs-number">10</span>)<br>Print(arr)<br>quickSort(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)<br>Print(arr)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过一次排序将要排序的数据分成两部分。一部分要比另外一部分小，两个部分进行分别排序。核心是分治法。</p></blockquote><h3 id="三，堆排序"><a href="#三，堆排序" class="headerlink" title="三，堆排序"></a>三，堆排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(n^2^)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420150936225-1441021270.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//堆排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>n := <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k := n / <span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">1</span>; k-- &#123;<br>sink(arr, k, n)<br>&#125;<br><span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span> &#123;<br>swap(arr, <span class="hljs-number">1</span>, n)<br>n--<br>sink(arr, <span class="hljs-number">1</span>, n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sink</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, k, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>i := <span class="hljs-number">2</span> * k<br><span class="hljs-keyword">if</span> i &gt; n &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; n &amp;&amp; s[i+<span class="hljs-number">1</span>] &gt; s[i] &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">if</span> s[k] &gt;= s[i] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>swap(s, k, i)<br>k = i<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>利用堆这种特殊的数据结构，完全的二叉树进行排序。大顶堆，小顶堆。</p></blockquote><h3 id="四，计数排序"><a href="#四，计数排序" class="headerlink" title="四，计数排序"></a>四，计数排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n+k)</li><li>最坏： O(n+k)</li><li>最好：O(n+k)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//计数排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>biger := GetArryMax(arr)<br>fmt.Println(<span class="hljs-string">&quot;zuida:&quot;</span>, biger)<br>orderarr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, biger+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>orderarr[v]++<br>&#125;<br><span class="hljs-keyword">var</span> resarr []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> orderarr &#123;<br><span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= v; j++ &#123;<br>resarr = <span class="hljs-built_in">append</span>(resarr, i)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> resarr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p></blockquote><h3 id="五，桶排序"><a href="#五，桶排序" class="headerlink" title="五，桶排序"></a>五，桶排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n+k)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.kanzhun.com%2Fimages%2Fseo%2Fmianshiti%2F20191125%2F8c57857f177717f04d1255c32dbbec4e.gif&refer=http%3A%2F%2Fimg.kanzhun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627895630&t=9153e406f528898ed2cc32a5b13b204e"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//桶排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>num := <span class="hljs-built_in">len</span>(arr)<br>max := GetArryMax(arr)<br>buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, num)<br>index := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>index = arr[i] * (num - <span class="hljs-number">1</span>) / max<br>buckets[index] = <span class="hljs-built_in">append</span>(buckets[index], arr[i])<br>&#125;<br>tmpPos := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>bucketLen := <span class="hljs-built_in">len</span>(buckets[i])<br><span class="hljs-keyword">if</span> bucketLen &gt; <span class="hljs-number">0</span> &#123;<br>SortInBucket(buckets[i])<br><span class="hljs-built_in">copy</span>(arr[tmpPos:], buckets[i])<br>tmpPos += bucketLen<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInBucket</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>length := <span class="hljs-built_in">len</span>(arr)<br><span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; length; i++ &#123;<br>backup := arr[i]<br>j := i - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; backup &lt; arr[j] &#123;<br>arr[j+<span class="hljs-number">1</span>] = arr[j]<br>j--<br>&#125;<br>arr[j+<span class="hljs-number">1</span>] = backup<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>桶排序是计数排序的升级版。解决了如果数据值范围过大造成的桶数量多的问题，进行函数映射处理缩小桶数量。但也增加了桶内排序的过程。</p></blockquote><h3 id="六，基数排序"><a href="#六，基数排序" class="headerlink" title="六，基数排序"></a>六，基数排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n*k)</li><li>最坏： O(n*k)</li><li>最好：O(n*k)</li></ul></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F7492974-c980be774a0cc76d.gif&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627895837&t=0c184d3053683c556a256d8824edacd7"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//基数排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>maxValLen := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>n := <span class="hljs-built_in">len</span>(strconv.Itoa(arr[i]))<br><span class="hljs-keyword">if</span> n &gt; maxValLen &#123;<br>maxValLen = n<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> loc := <span class="hljs-number">1</span>; loc &lt;= maxValLen; loc++ &#123;<br>Sort(arr, loc)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, loc <span class="hljs-type">int</span>)</span></span> &#123;<br>bucket := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>ji := digit(arr[i], loc)<br><span class="hljs-keyword">if</span> bucket[ji] == <span class="hljs-literal">nil</span> &#123;<br>bucket[ji] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>&#125;<br>bucket[ji] = <span class="hljs-built_in">append</span>(bucket[ji], arr[i])<br>&#125;<br><br>idx := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(bucket[i]); j++ &#123;<br>arr[idx] = bucket[i][j]<br>idx++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>基数排序的性能要比桶排序略微差一点。基于分别排序，分别收集，是稳定的。</p></blockquote><h3 id="七，总结"><a href="#七，总结" class="headerlink" title="七，总结"></a>七，总结</h3><blockquote><p>重新梳理排序算法的目的，就是加深印象。用golang进行实现也锻炼了逻辑思维能力。拓宽了视野。遇到问题不能只会一个冒泡，快排也可以考虑一下的哈。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2024/08/12/%E6%A0%88/"/>
    <url>/2024/08/12/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><hr><h3 id="一，栈的定义"><a href="#一，栈的定义" class="headerlink" title="一，栈的定义"></a>一，栈的定义</h3><blockquote><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p><p>我们把允许插入和删除的一端称为栈顶（<strong>top</strong>）。另一端称为栈底（<strong>bottom</strong>）。不含任何元素的栈称为空栈。</p><p>栈又称为后进先出的线性表。（<strong>Last In Fist Out</strong>）<strong>LIFO</strong> 结构</p></blockquote><blockquote><p>最先进栈的就一定最后出栈吗？当然不是，应该说是不一定，因为第一个进栈如果，第二个进栈前就出栈了，对吧。</p></blockquote><blockquote><p>线性表有顺序结构和链式结构，同样栈也是这样。</p><p>顺序结构的有扩容问题，链式结构的不存在扩容问题。</p></blockquote><h3 id="二，golang实现栈结构"><a href="#二，golang实现栈结构" class="headerlink" title="二，golang实现栈结构"></a>二，golang实现栈结构</h3><blockquote><p>公共参数</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//长度</span><br><span class="hljs-keyword">const</span> MaxSize = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;<br>Data [MaxSize]<span class="hljs-type">int</span><br>Top  <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//打印栈</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Print() &#123;<br>fmt.Println(s.Data)<br>&#125;<br><span class="hljs-comment">//push</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Push(val <span class="hljs-type">int</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s.Top == MaxSize<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;空间已满&quot;</span>)<br>&#125;<br>s.Data[s.Top] = val<br>s.Top++<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">//pop</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Pop() (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s.Top == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;没有元素了&quot;</span>)<br>&#125;<br>s.Top--<br><span class="hljs-keyword">return</span> s.Data[s.Top], <span class="hljs-literal">nil</span> <span class="hljs-comment">//这样容易产生内存泄漏。因为这个元素在顺序结构中还存在呢。并没有清理掉。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>虽然指针进行了偏移，但是由于此对象依然存在于内存中。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-number">3</span> &lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">2</span> &lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">1</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] <br>PASS<br></code></pre></td></tr></table></figure><blockquote><p>优化pop接口之后</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//将已经取出的元素进行置空操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Pop_New() (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s.Top == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;没有元素了&quot;</span>)<br>&#125;<br>s.Top--<br>v := s.Data[s.Top]<br>s.Data[s.Top] = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span> <span class="hljs-comment">//清理掉,Pop的元素。</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-number">6</span> &lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">5</span> &lt;<span class="hljs-literal">nil</span>&gt;<br><span class="hljs-number">4</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br>PASS<br></code></pre></td></tr></table></figure><h4 id="2-链式结构"><a href="#2-链式结构" class="headerlink" title="2.链式结构"></a>2.链式结构</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//链式栈</span><br><span class="hljs-keyword">type</span> ChainStack <span class="hljs-keyword">struct</span> &#123;<br>head  *Chain<br>count <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//链</span><br><span class="hljs-keyword">type</span> Chain <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">int</span><br>Next *Chain<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//打印链的数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ChainStack)</span></span> Print() &#123;<br>content := <span class="hljs-string">&quot;&quot;</span><br>cur := s.head<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>content += strconv.Itoa(cur.Data) + <span class="hljs-string">&quot; &quot;</span><br>cur = cur.Next<br>&#125;<br>fmt.Println(content)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ChainStack)</span></span> Push(data <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>head := &amp;Chain&#123;<br>Data: data,<br>Next: s.head,<br>&#125;<br>s.head = head<br>s.count++<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//抛出数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ChainStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>content := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> s.head != <span class="hljs-literal">nil</span> &#123;<br>content = s.head.Data<br>s.head = s.head.Next<br>s.count--<br>&#125;<br><span class="hljs-keyword">return</span> content<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三，双栈共享空间结构"><a href="#三，双栈共享空间结构" class="headerlink" title="三，双栈共享空间结构"></a>三，双栈共享空间结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//双栈共享空间结构</span><br><span class="hljs-keyword">type</span> DoubleStack <span class="hljs-keyword">struct</span> &#123;<br>Data []<span class="hljs-type">int</span><br>Top1 <span class="hljs-type">int</span><br>Top2 <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//创建双栈共享空间结构对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDoubleStack</span><span class="hljs-params">()</span></span> *DoubleStack &#123;<br><span class="hljs-keyword">return</span> &amp;DoubleStack&#123;<br>Data: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, MaxSize),<br>Top1: <span class="hljs-number">0</span>,<br>Top2: MaxSize - <span class="hljs-number">1</span>,<br>&#125;<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DoubleStack)</span></span> Print() &#123;<br>fmt.Println(d.Data)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>栈操作</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//push</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DoubleStack)</span></span> Push(val <span class="hljs-type">int</span>, stackNum <span class="hljs-type">int</span>) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> d.Top1+<span class="hljs-number">1</span> == d.Top2 &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;空间已经满了&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> stackNum == <span class="hljs-number">1</span> &#123;<br>d.Data[d.Top1] = val<br>d.Top1++<br>&#125;<br><span class="hljs-keyword">if</span> stackNum == <span class="hljs-number">2</span> &#123;<br>d.Data[d.Top2] = val<br>d.Top2--<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">//pop</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *DoubleStack)</span></span> Pop(stackNum <span class="hljs-type">int</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> stackNum == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">if</span> d.Top1 == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;栈1已经空了&quot;</span>)<br>&#125;<br>v := d.Data[d.Top1]<br>d.Data[d.Top1] = <span class="hljs-number">0</span><br>d.Top1--<br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> stackNum == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">if</span> d.Top2 == MaxSize<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;栈2已经空了&quot;</span>)<br>&#125;<br>d.Top2++<br>v := d.Data[d.Top2]<br>d.Data[d.Top2] = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;stackNum wrong&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试代码和打印内容</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_DoubleStack</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>dou := NewDoubleStack()<br>dou.Push(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>dou.Push(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>dou.Push(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>dou.Print()<br>dou.Pop(<span class="hljs-number">1</span>)<br>dou.Pop(<span class="hljs-number">1</span>)<br>dou.Pop(<span class="hljs-number">1</span>)<br>dou.Pop(<span class="hljs-number">2</span>)<br>dou.Print()<br>&#125;<br><span class="hljs-comment">//打印内容</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span>]<br>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br>PASS<br></code></pre></td></tr></table></figure><blockquote><p>这种双栈共享空间的结构，一般根据实际情况，不会出现栈满的情况，原因是两个栈是互补的关系。</p></blockquote><h3 id="四，总结"><a href="#四，总结" class="headerlink" title="四，总结"></a>四，总结</h3><blockquote><p>栈这种数据结构就是用来处理需要预存对象的业务场景，有代表性的处理场景就是<strong>逆波兰表示</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法--线性表</title>
    <link href="/2024/08/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2024/08/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构和算法–线性表"><a href="#数据结构和算法–线性表" class="headerlink" title="数据结构和算法–线性表"></a>数据结构和算法–线性表</h2><hr><h3 id="一，线性表"><a href="#一，线性表" class="headerlink" title="一，线性表"></a>一，线性表</h3><blockquote><p>零个或多个数据元素的有限序列</p></blockquote><h4 id="1，数组"><a href="#1，数组" class="headerlink" title="1，数组"></a>1，数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">数组<br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arry := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">11</span>&#125;<br>fmt.Println(arry[<span class="hljs-number">2</span>])<br>fmt.Println(findVal(arry,<span class="hljs-number">3</span>))<br>&#125;<br><span class="hljs-comment">//查询数组中是否存在要查找的值，返回数组下标，如果没有返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findVal</span><span class="hljs-params">(arry []<span class="hljs-type">int</span>, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">for</span> i,a:=<span class="hljs-keyword">range</span> arry&#123;<br><span class="hljs-keyword">if</span> a==<span class="hljs-number">3</span>&#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">//找到相同元素的位置并插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertVal</span><span class="hljs-params">(arry []<span class="hljs-type">int</span>, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>index := findVal(arry, a)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Println(arry[:index])<br>res = <span class="hljs-built_in">append</span>(res, arry[:index]...)<br>res = <span class="hljs-built_in">append</span>(res, a)<br>res = <span class="hljs-built_in">append</span>(res, arry[index:]...)<br>fmt.Println(res)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>查询速度快，但是插入和删除会移动大量的元素。</p></blockquote><h4 id="2，链表"><a href="#2，链表" class="headerlink" title="2，链表"></a>2，链表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//节点</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>   Data <span class="hljs-keyword">interface</span>&#123;&#125; <br>   Next *Node  <br>&#125;<br><span class="hljs-comment">//单链表</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>headNode *Node <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链表也是线性表，插入和删除不需要移动大量元素了。</p></blockquote><h5 id="1，头插法"><a href="#1，头插法" class="headerlink" title="1，头插法"></a>1，头插法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Add(data Object) *Node &#123;<br>   node := &amp;Node&#123;Data: data&#125;<br>   node.Next = l.headNode<br>   l.headNode = node<br>   <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>jdk1.7之前，HashMap 是数组链表来实现的，链表采用的是头插法，方便插入元素。但是HashMap不是线程安全的，多线程中如果数组扩容会出现环链的现象。1.8之后采用尾插法，尾插法避免了环链，但是插入的效率明显降低了。</p></blockquote><h5 id="2，尾插法"><a href="#2，尾插法" class="headerlink" title="2，尾插法"></a>2，尾插法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//尾插法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Append(data <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>node := &amp;Node&#123;Data: data&#125;<br><span class="hljs-keyword">if</span> l.IsEmpty() &#123;<br>l.headNode = node<br>&#125;<br>cur := l.headNode<br><span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>cur = cur.Next<br>&#125;<br>cur.Data = node<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>尾插法需要遍历到尾部，才能插入元素，但是因为链表复制的时候不会出现，新的链表元素顺序和原来的链表是一样的。不会出现环链了。多线程的情况下，如果扩容，线程挂起，也就是在执行一遍链表的复制而已。避免了环链的产生。</p><p>突然感觉刚才创建的结构不合适，因为尾插法会比较慢。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//修改之后的单链表</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>headNode *Node<br>    lastNode *Node<br>    length   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样就可以直接找到尾部，还可以更加方便的进行二分法查找</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Add(data <span class="hljs-keyword">interface</span>&#123;&#125;) *Node &#123;<br>node := &amp;Node&#123;Data: data&#125;<br><span class="hljs-keyword">if</span> l.IsEmpty() &#123;<br>l.headNode = node<br>l.lastNode = node<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node.Next = l.headNode<br>l.headNode = node<br>&#125;<br>l.length++<br><span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//尾插法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Append(data <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>node := &amp;Node&#123;Data: data&#125;<br><span class="hljs-keyword">if</span> l.IsEmpty() &#123;<br>l.headNode = node<br>l.lastNode = node<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l.lastNode.Next = node<br>l.lastNode = node<br>&#125;<br>l.length++<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3，链表排序"><a href="#3，链表排序" class="headerlink" title="3，链表排序"></a>3，链表排序</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_Order</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>l := &amp;List&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>l.Add(i)<br>&#125;<br>l.orderList()<br>fmt.Println(<span class="hljs-string">&quot;排序后：&quot;</span>,l.count)<br>cur := l.headNode<br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(cur.Data)<br>cur = cur.Next<br><span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> orderList() &#123;<br>cur := l.headNode<br><span class="hljs-keyword">for</span> &#123;<br>cur = l.Change(cur)<br>fmt.Println(cur.Data)<br><span class="hljs-keyword">if</span> cur.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Change(cur *Node) *Node &#123;<br><span class="hljs-keyword">if</span> cur.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>second := cur.Next<br><span class="hljs-keyword">if</span> cur.Data.(<span class="hljs-type">int</span>) &gt; second.Data.(<span class="hljs-type">int</span>) &#123;<br>         l.count++<br>tmp := cur.Data<br>cur.Data = second.Data<br>second.Data = tmp<br><span class="hljs-keyword">return</span> l.headNode<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> second<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>统计了下执行次数：174次</p></blockquote><h3 id="二，总结"><a href="#二，总结" class="headerlink" title="二，总结"></a>二，总结</h3><blockquote><p>数组的修改会比较的麻烦，因为大量的元素需要整体移动。链表在插入，修改方面进行了优化。</p><p>链表在读取方面和数组虽然有差异但是效率差不多。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法  上篇</title>
    <link href="/2024/08/12/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8A/"/>
    <url>/2024/08/12/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法-上篇"><a href="#经典排序算法-上篇" class="headerlink" title="经典排序算法  上篇"></a>经典排序算法  上篇</h2><hr><h3 id="一，准备工作"><a href="#一，准备工作" class="headerlink" title="一，准备工作"></a>一，准备工作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//获取随机的数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArry</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, count)<br>    rand.Seed(time.Now().UnixNano())<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>        arr[i] = rand.Intn(<span class="hljs-number">100</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;打印:&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Println(k)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二，冒泡排序"><a href="#二，冒泡排序" class="headerlink" title="二，冒泡排序"></a>二，冒泡排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    l := <span class="hljs-built_in">len</span>(arr)<br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; l<span class="hljs-number">-1</span>-i; j++ &#123;<br>            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>                tmp := arr[j+<span class="hljs-number">1</span>]<br>                arr[j+<span class="hljs-number">1</span>] = arr[j]<br>                arr[j] = tmp<br>            &#125;<br>            count++<br>        &#125;<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;冒泡排序次数：&quot;</span>, count)<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>冒泡排序是一种简单的排序算法。它重复的遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把他们交换过来。冒泡就是把越小的元素经由交换慢慢显现出来。</p></blockquote><h3 id="三，选择排序"><a href="#三，选择排序" class="headerlink" title="三，选择排序"></a>三，选择排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//选择排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    l := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">var</span> minindex, tmp, count <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br>        minindex = i<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; l; j++ &#123;<br>            <span class="hljs-keyword">if</span> arr[j] &lt; arr[minindex] &#123;<br>                minindex = j<br>            &#125;<br>            count++<br>        &#125;<br>        tmp = arr[i]<br>        arr[i] = arr[minindex]<br>        arr[minindex] = tmp<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;选择排序次数：&quot;</span>, count)<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>选择排序是一种比较直观的排序算法。首先在未排序列中找到最小(大)的元素，放到起始位置，然后，再从剩余的未排序的元素中继续寻找最小(大)元素，然后放到排序序列的末尾。以此类推，直到排序完成。</p></blockquote><h3 id="四，插入排序"><a href="#四，插入排序" class="headerlink" title="四，插入排序"></a>四，插入排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^2^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//插入排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    l := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">var</span> preindex, curr <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; l; i++ &#123;<br>        preindex = i - <span class="hljs-number">1</span><br>        curr = arr[i]<br>        <span class="hljs-keyword">for</span> preindex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preindex] &gt; curr &#123;<br>            arr[preindex+<span class="hljs-number">1</span>] = arr[preindex]<br>            preindex--<br>        &#125;<br>        arr[preindex+<span class="hljs-number">1</span>] = curr<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>插入排序算法描述的是一种简单直观的构建有序序列的排序算法。工作原理是 对于未排序的数据，在已排序的数据从后向前进行扫描，找到相应的位置并插入。</p></blockquote><h3 id="五，希尔排序"><a href="#五，希尔排序" class="headerlink" title="五，希尔排序"></a>五，希尔排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(n^1.3^)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    l := <span class="hljs-built_in">len</span>(arr)<br>    middle := math.Floor(<span class="hljs-type">float64</span>(l / <span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">for</span> gap := <span class="hljs-type">int</span>(middle); gap &gt; <span class="hljs-number">0</span>; gap = <span class="hljs-type">int</span>(math.Floor(<span class="hljs-type">float64</span>(gap / <span class="hljs-number">2</span>))) &#123;<br>        <span class="hljs-keyword">for</span> i := gap; i &lt; l; i++ &#123;<br>            j := i<br>            curr := arr[i]<br>            <span class="hljs-keyword">for</span> j-gap &gt;= <span class="hljs-number">0</span> &amp;&amp; curr &lt; arr[j-gap] &#123;<br>                arr[j] = arr[j-gap]<br>                j = j - gap<br>            &#125;<br>            arr[j] = curr<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>1959年Shell发明，第一个突破O(n^2^)的排序算法，是简单插入排序的改进版。与插入排序不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p></blockquote><h3 id="六，归并排序"><a href="#六，归并排序" class="headerlink" title="六，归并排序"></a>六，归并排序</h3><blockquote><p>时间复杂度：</p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(nlog<del>2</del>n)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start &gt;= end &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    mid := (start + end) / <span class="hljs-number">2</span><br>    mergeSort(arr, start, mid)<br>    mergeSort(arr, mid+<span class="hljs-number">1</span>, end)<br>    merge(arr, start, mid, end)<br>&#125;<br><span class="hljs-comment">//划分不同的分区</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, mid, end <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> tmparr = []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> s1, s2 = start, mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> s1 &lt;= mid &amp;&amp; s2 &lt;= end &#123;<br>        <span class="hljs-keyword">if</span> arr[s1] &gt; arr[s2] &#123;<br>            tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s2])<br>            s2++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s1])<br>            s1++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> s1 &lt;= mid &#123;<br>        tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s1:mid+<span class="hljs-number">1</span>]...)<br>    &#125;<br>    <span class="hljs-keyword">if</span> s2 &lt;= end &#123;<br>        tmparr = <span class="hljs-built_in">append</span>(tmparr, arr[s2:end+<span class="hljs-number">1</span>]...)<br>    &#125;<br>    <span class="hljs-keyword">for</span> pos, item := <span class="hljs-keyword">range</span> tmparr &#123;<br>        arr[start+pos] = item<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法采用的是分治法的一个非常经典的应用。将已有序的子序列进行合并得到完全有序的序列。</p></blockquote><h4 id="七，总结"><a href="#七，总结" class="headerlink" title="七，总结"></a>七，总结</h4><blockquote><p>排序算法，排序对于查询来说有着非凡的意义。如果想要快速的查询数据，排序是避不开的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法  下篇</title>
    <link href="/2024/08/12/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8B/"/>
    <url>/2024/08/12/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法-下篇"><a href="#经典排序算法-下篇" class="headerlink" title="经典排序算法  下篇"></a>经典排序算法  下篇</h2><hr><h3 id="一，准备工作"><a href="#一，准备工作" class="headerlink" title="一，准备工作"></a>一，准备工作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//获取随机的数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArry</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, count)<br>rand.Seed(time.Now().UnixNano())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>arr[i] = rand.Intn(<span class="hljs-number">100</span>)<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;打印:&quot;</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Println(k)<br>&#125;<br>&#125;<br><span class="hljs-comment">//交换位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><span class="hljs-comment">//获取最大的元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArryMax</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>biger := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br><span class="hljs-keyword">if</span> v &gt; biger &#123;<br>biger = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> biger<br>&#125;<br><span class="hljs-comment">//获取数字位的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digit</span><span class="hljs-params">(num <span class="hljs-type">int</span>, loc <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num % <span class="hljs-type">int</span>(math.Pow10(loc)) / <span class="hljs-type">int</span>(math.Pow10(loc<span class="hljs-number">-1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二，快速排序"><a href="#二，快速排序" class="headerlink" title="二，快速排序"></a>二，快速排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(n^2^)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> start &lt; end &#123;<br>i, j := start, end<br>key := arr[(start+end)/<span class="hljs-number">2</span>]<br><span class="hljs-keyword">for</span> i &lt;= j &#123;<br><span class="hljs-keyword">for</span> arr[i] &lt; key &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> arr[j] &gt; key &#123;<br>j--<br>&#125;<br><span class="hljs-keyword">if</span> i &lt;= j &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>i++<br>j--<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> start &lt; j &#123;<br>quickSort(arr, start, j)<br>&#125;<br><span class="hljs-keyword">if</span> end &gt; i &#123;<br>quickSort(arr, i, end)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_FastSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>arr := GetArry(<span class="hljs-number">10</span>)<br>Print(arr)<br>quickSort(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)<br>Print(arr)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过一次排序将要排序的数据分成两部分。一部分要比另外一部分小，两个部分进行分别排序。核心是分治法。</p></blockquote><h3 id="三，堆排序"><a href="#三，堆排序" class="headerlink" title="三，堆排序"></a>三，堆排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(nlog<del>2</del>n)</li><li>最坏： O(n^2^)</li><li>最好：O(nlog<del>2</del>n)</li></ul></blockquote><p><img src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420150936225-1441021270.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//堆排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>n := <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k := n / <span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">1</span>; k-- &#123;<br>sink(arr, k, n)<br>&#125;<br><span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span> &#123;<br>swap(arr, <span class="hljs-number">1</span>, n)<br>n--<br>sink(arr, <span class="hljs-number">1</span>, n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sink</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, k, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>i := <span class="hljs-number">2</span> * k<br><span class="hljs-keyword">if</span> i &gt; n &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; n &amp;&amp; s[i+<span class="hljs-number">1</span>] &gt; s[i] &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">if</span> s[k] &gt;= s[i] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>swap(s, k, i)<br>k = i<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>利用堆这种特殊的数据结构，完全的二叉树进行排序。大顶堆，小顶堆。</p></blockquote><h3 id="四，计数排序"><a href="#四，计数排序" class="headerlink" title="四，计数排序"></a>四，计数排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n+k)</li><li>最坏： O(n+k)</li><li>最好：O(n+k)</li></ul></blockquote><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//计数排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>biger := GetArryMax(arr)<br>fmt.Println(<span class="hljs-string">&quot;zuida:&quot;</span>, biger)<br>orderarr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, biger+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>orderarr[v]++<br>&#125;<br><span class="hljs-keyword">var</span> resarr []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> orderarr &#123;<br><span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= v; j++ &#123;<br>resarr = <span class="hljs-built_in">append</span>(resarr, i)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> resarr<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p></blockquote><h3 id="五，桶排序"><a href="#五，桶排序" class="headerlink" title="五，桶排序"></a>五，桶排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n+k)</li><li>最坏： O(n^2^)</li><li>最好：O(n)</li></ul></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.kanzhun.com%2Fimages%2Fseo%2Fmianshiti%2F20191125%2F8c57857f177717f04d1255c32dbbec4e.gif&refer=http%3A%2F%2Fimg.kanzhun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627895630&t=9153e406f528898ed2cc32a5b13b204e"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//桶排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>num := <span class="hljs-built_in">len</span>(arr)<br>max := GetArryMax(arr)<br>buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, num)<br>index := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>index = arr[i] * (num - <span class="hljs-number">1</span>) / max<br>buckets[index] = <span class="hljs-built_in">append</span>(buckets[index], arr[i])<br>&#125;<br>tmpPos := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>bucketLen := <span class="hljs-built_in">len</span>(buckets[i])<br><span class="hljs-keyword">if</span> bucketLen &gt; <span class="hljs-number">0</span> &#123;<br>SortInBucket(buckets[i])<br><span class="hljs-built_in">copy</span>(arr[tmpPos:], buckets[i])<br>tmpPos += bucketLen<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortInBucket</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>length := <span class="hljs-built_in">len</span>(arr)<br><span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; length; i++ &#123;<br>backup := arr[i]<br>j := i - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; backup &lt; arr[j] &#123;<br>arr[j+<span class="hljs-number">1</span>] = arr[j]<br>j--<br>&#125;<br>arr[j+<span class="hljs-number">1</span>] = backup<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>桶排序是计数排序的升级版。解决了如果数据值范围过大造成的桶数量多的问题，进行函数映射处理缩小桶数量。但也增加了桶内排序的过程。</p></blockquote><h3 id="六，基数排序"><a href="#六，基数排序" class="headerlink" title="六，基数排序"></a>六，基数排序</h3><blockquote><p>时间复杂度: </p><ul><li>平均：O(n*k)</li><li>最坏： O(n*k)</li><li>最好：O(n*k)</li></ul></blockquote><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F7492974-c980be774a0cc76d.gif&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627895837&t=0c184d3053683c556a256d8824edacd7"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//基数排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>maxValLen := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>n := <span class="hljs-built_in">len</span>(strconv.Itoa(arr[i]))<br><span class="hljs-keyword">if</span> n &gt; maxValLen &#123;<br>maxValLen = n<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> loc := <span class="hljs-number">1</span>; loc &lt;= maxValLen; loc++ &#123;<br>Sort(arr, loc)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, loc <span class="hljs-type">int</span>)</span></span> &#123;<br>bucket := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>ji := digit(arr[i], loc)<br><span class="hljs-keyword">if</span> bucket[ji] == <span class="hljs-literal">nil</span> &#123;<br>bucket[ji] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>&#125;<br>bucket[ji] = <span class="hljs-built_in">append</span>(bucket[ji], arr[i])<br>&#125;<br><br>idx := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(bucket[i]); j++ &#123;<br>arr[idx] = bucket[i][j]<br>idx++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>基数排序的性能要比桶排序略微差一点。基于分别排序，分别收集，是稳定的。</p></blockquote><h3 id="七，总结"><a href="#七，总结" class="headerlink" title="七，总结"></a>七，总结</h3><blockquote><p>重新梳理排序算法的目的，就是加深印象。用golang进行实现也锻炼了逻辑思维能力。拓宽了视野。遇到问题不能只会一个冒泡，快排也可以考虑一下的哈。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连续数字的字符串</title>
    <link href="/2024/08/12/%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/08/12/%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="连续数字的字符串"><a href="#连续数字的字符串" class="headerlink" title="连续数字的字符串"></a>连续数字的字符串</h2><hr><h3 id="一，前言"><a href="#一，前言" class="headerlink" title="一，前言"></a>一，前言</h3><blockquote><p>开发过程中经常会遇到生成连续的数字字符串，如果连续数字的字符串有哪些技巧和问题呢？</p></blockquote><h3 id="二，第一种处理方法"><a href="#二，第一种处理方法" class="headerlink" title="二，第一种处理方法"></a>二，第一种处理方法</h3><blockquote><p>通过for循环来处理，条件就是从1开始，小于输入的数字，每次递增。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//简单粗暴直接拼接就可以了。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateArray1</span><span class="hljs-params">(length <span class="hljs-type">int</span>)</span></span>[]<span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">if</span> length &gt; <span class="hljs-number">0</span> &#123;<br>arr := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= length; i++ &#123;<br>arr += fmt.Sprint(i)<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种方式的好处是没有类型转换的操作。但是字符串的拼接会造成大量的空间浪费，因为每次的字符串都是新的对象。短时间生成了大量的垃圾，加重了垃圾回收的压力。</p><p>如果字符串的长度特别长了之后操作就会很浪费内存的。毕竟生成的字符串都是新的！！！</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//创建数组，最后通过数组转换。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateArray2</span><span class="hljs-params">(length <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> length &gt; <span class="hljs-number">0</span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, length)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= length; i++ &#123;<br>arr[i<span class="hljs-number">-1</span>] = fmt.Sprint(i)<br>&#125;<br><span class="hljs-keyword">return</span> strings.Join(arr, <span class="hljs-string">&quot;,&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种方式虽然处理了字符串拼接造成的空间浪费。速度是非常的快。基本已经可以满足大部分的业务场景了。</p></blockquote><h3 id="三，测试时间差"><a href="#三，测试时间差" class="headerlink" title="三，测试时间差"></a>三，测试时间差</h3><ul><li>测试代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//测试时间差</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_CreateArry</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>start := time.Now().Unix()<br>CreateArray1(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>end := time.Now().Unix()<br>dur := end - start<br>fmt.Printf(<span class="hljs-string">&quot;durstr: %v\n&quot;</span>, dur)<br><br>start = time.Now().Unix()<br>CreateArray2(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>end = time.Now().Unix()<br>dur = end - start<br>fmt.Printf(<span class="hljs-string">&quot;durarry: %v\n&quot;</span>, dur)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang">durstr: <span class="hljs-number">297</span><br>durarry: <span class="hljs-number">0</span><br>PASS<br></code></pre></td></tr></table></figure><blockquote><p>从结果分析，当拼接的数量变大的时候，数组实现和字符串拼接的时间差距特别的大。</p></blockquote><h3 id="四，总结"><a href="#四，总结" class="headerlink" title="四，总结"></a>四，总结</h3><blockquote><p>字符串的操作，</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预定义标识符</title>
    <link href="/2024/04/23/%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <url>/2024/04/23/%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="预定义标识符列表"><a href="#预定义标识符列表" class="headerlink" title="预定义标识符列表"></a>预定义标识符列表</h4><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>append</td><td>bool</td><td>byte</td><td>cap</td><td>close</td><td>complex</td></tr><tr><td>complex64</td><td>complex128</td><td>uint16</td><td>copy</td><td>false</td><td>float32</td></tr><tr><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>int32</td></tr><tr><td>uint32</td><td>int64</td><td>uint64</td><td>iota</td><td>len</td><td>make</td></tr><tr><td>new</td><td>nil</td><td>panic</td><td>print</td><td>println</td><td>real</td></tr><tr><td>recover</td><td>string</td><td>true</td><td>uint</td><td>unit8</td><td>uintptr</td></tr></tbody></table><p>这里面涵盖了类型，基础函数，关键字等。</p><p>append是切片的扩展函数。</p><p>cap是容量函数。</p><p>len是长度函数。</p><p>make是特殊变量声明并初始化函数。</p><p>new是声明变量函数。</p><p>panic是异常触发函数。</p><p>recover是恢复函数。</p><p>nil是空状态标识符。</p><p>其他基本都是类型标识符了。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go关键字</title>
    <link href="/2024/04/16/go%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/16/go%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="Go关键字"><a href="#Go关键字" class="headerlink" title="Go关键字"></a>Go关键字</h3><hr><h4 id="一，介绍golang的25个关键字"><a href="#一，介绍golang的25个关键字" class="headerlink" title="一，介绍golang的25个关键字"></a>一，介绍golang的25个关键字</h4><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>for</td><td>range</td><td>select</td><td>chan</td><td>default</td></tr><tr><td>if</td><td>fallthrough</td><td>go</td><td>func</td><td>interface</td></tr><tr><td>break</td><td>const</td><td>package</td><td>struct</td><td>switch</td></tr><tr><td>type</td><td>var</td><td>return</td><td>defer</td><td>else</td></tr><tr><td>goto</td><td>map</td><td>continue</td><td>case</td><td>import</td></tr></tbody></table><h4 id="二，最简单的golang代码"><a href="#二，最简单的golang代码" class="headerlink" title="二，最简单的golang代码"></a>二，最简单的golang代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-comment">// package 定义包名 main 是默认的入口包。</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">// import 引入依赖包</span><br><br><span class="hljs-keyword">const</span> ( <br>    <span class="hljs-comment">// 定义常量</span><br>    Name = <span class="hljs-string">&quot;John&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// type 自定义类型 struct </span><br>    Name <span class="hljs-type">string</span><br>    Age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// main 函数也是入口函数 func 定义函数</span><br><br>    user := User&#123;<br>        Name: Name,<br>        Age: <span class="hljs-number">30</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;hello world %v&quot;</span>, user)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个最简单的golang程序代码，必须要包含 package 包 func 函数。当然如果不写func也不会报错。但是一个空包对于程序来说没有意义。</p><h4 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h4><p>golang 入门特别简单，如果是从其他语言转过来的话，会更加的快。因为golang这个语言特别年轻，在成长过程中吸纳了现今流行的其他语言的很多优点，</p><p>golang官方的 宣传语：<strong>Build simple, secure, scalable systems with</strong></p><p>简洁是这个语言最大的亮点。</p><p>感谢阅读至此，欢迎留言交流。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言基础</title>
    <link href="/2024/04/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/16/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h3><hr><h4 id="一，基础类型"><a href="#一，基础类型" class="headerlink" title="一，基础类型"></a>一，基础类型</h4><p>在包 builtin 里面定义了基础类型</p><ul><li><p>bool</p></li><li><p>uint8</p></li><li><p>uint16</p></li><li><p>uint32</p></li><li><p>uint64</p></li><li><p>int8</p></li><li><p>int16</p></li><li><p>int32</p></li><li><p>int64</p></li><li><p>float32</p></li><li><p>float64</p></li><li><p>complex64</p></li><li><p>complex128</p></li><li><p>string</p></li><li><p>int</p></li><li><p>uint</p></li><li><p>uintptr</p></li><li><p>byte &#x3D; uint8</p></li><li><p>rune &#x3D; int32</p></li><li><p>any &#x3D; interface{}</p></li></ul><p>以上是golang基础类型和一些类型的变体。</p><h4 id="二，个别需要注意的类型"><a href="#二，个别需要注意的类型" class="headerlink" title="二，个别需要注意的类型"></a>二，个别需要注意的类型</h4><ul><li>其中string的注释是这样描述的：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// string is the set of all strings of 8-bit bytes, conventionally but not </span><br><br><span class="hljs-comment">// necessarily representing UTF-8-encoded text. A string may be empty, but </span><br><br><span class="hljs-comment">// not nil. Values of string type are immutable.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">string</span> <span class="hljs-type">string</span><br><br> 直接翻译过来： <br><br><span class="hljs-type">string</span> 是所有 <span class="hljs-number">8</span> 位字节字符串的集合，通常但不是<br><br>必须表示 UTF<span class="hljs-number">-8</span> 编码的文本。字符串可以为空，<br><br>但 不是没有。字符串类型的值是不可变的。<br></code></pre></td></tr></table></figure><ul><li>int 至少是32位有符号的整型。也就是不能等于 int32。对比着int32的来看</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// int is a signed integer type that is at least 32 bits in size. It is a</span><br><span class="hljs-comment">// distinct type, however, and not an alias for, say, int32.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">int</span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// int32 is the set of all signed 32-bit integers.</span><br><span class="hljs-comment">// Range: -2147483648 through 2147483647.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">int32</span> <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><ul><li>类型别名，byte，rune，any。我如果没有记错，java里面的byte是有符号的 int8 .范围是 -128~127</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span><br><span class="hljs-comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span><br><span class="hljs-comment">// integer values.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">byte</span> = <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span><br><span class="hljs-comment">// used, by convention, to distinguish character values from integer values.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br><br><span class="hljs-comment">// any is an alias for interface&#123;&#125; and is equivalent to interface&#123;&#125; in all ways.</span><br><span class="hljs-keyword">type</span> any = <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h4><ul><li><p>通过将buildin 文件里面的源码分析，大部分类型和其他语言一样。</p></li><li><p>个别类型却有不一样的设定。int大小其实是不固定的。</p></li><li><p>为了方便golang还将一些类型取了别名。同时有一个新的名称rune。</p></li><li><p>我记得以前的版本应该是没有 any 类型的。猜测是go1.18之后才有的，因为泛型之后 就不用 interface{} 到处传递了，代码整洁美观了不少。</p></li><li><p>最后欢迎留言交流指正。感谢阅读至此。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
